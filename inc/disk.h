/**
 * @file disk.h
 * @author James Carr
 * @brief ATA Disk Driver header using PIO Mode and LBA28 Addressing for access upto 128Gb.
 * @version 0.1
 * @date 31/03/2022.
 *

REGISTERS

 Offset from "I/O" base

Direction	Function	Description	Param. size LBA28/LBA48
0	R/W	    Data Register	Read/Write PIO data bytes	16-bit / 16-bit
1	R	    Error Register	Used to retrieve any error generated by the last ATA command executed.	8-bit / 16-bit
1	W	    Features Register	Used to control command specific interface features.	8-bit / 16-bit
2	R/W	    Sector Count Register	Number of sectors to read/write (0 is a special value).	8-bit / 16-bit
3	R/W	    Sector Number Register / (LBAlo)	This is CHS / LBA28 / LBA48 specific.	8-bit / 16-bit
4	R/W	    Cylinder Low Register / (LBAmid)	Partial Disk Sector address.	8-bit / 16-bit
5	R/W	    Cylinder High Register / (LBAhi)	Partial Disk Sector address.	8-bit / 16-bit
6	R/W	    Drive / Head Register	Used to select a drive and/or head. Supports extra address/flag bits.	8-bit / 8-bit
7	R	    Status Register	Used to read the current status.	8-bit / 8-bit
7	W	    Command Register	Used to send ATA commands to the device.	8-bit / 8-bit

Offset from "Control" base

Direction	Function	Description	Param. size LBA28/LBA48
0	R	Alternate Status Register	A duplicate of the Status Register which does not affect interrupts.	8-bit / 8-bit
0	W	Device Control Register	Used to reset the bus or enable/disable interrupts.	8-bit / 8-bit
1	R	Drive Address Register	Provides drive select and head select information.	8-bit / 8-bit


Status Register (I/O base + 7)

Bit	Abbreviation	Function
0	ERR	Indicates an error occurred. Send a new command to clear it (or nuke it with a Software Reset).
1	IDX	Index. Always set to zero.
2	CORR	Corrected data. Always set to zero.
3	DRQ	Set when the drive has PIO data to transfer, or is ready to accept PIO data.
4	SRV	Overlapped Mode Service Request.
5	DF	Drive Fault Error (does not set ERR).
6	RDY	Bit is clear when drive is spun down, or after an error. Set otherwise.
7	BSY	Indicates the drive is preparing to send/receive data (wait for it to clear). In case of 'hang' (it never clears), do a software reset.

 */

#ifndef SIMPLEOS_DISK_H
#define SIMPLEOS_DISK_H

#define ATA_PRIMARY_BUS 0x1F0
#define ATA_SECTOR_COUNT 0x1F2
#define ATA_LBA_LOW 0x1F3
#define ATA_LBA_MID 0x1F4
#define ATA_LBA_HIGH 0x1F5
#define ATA_DRIVE 0x1F6
#define ATA_STATUS 0x1F7
#define ATA_CMD 0x1F7
#define ATA_STATUS_BSY_FLAG 0x08

#define LBA_MASTER_ADDRESSING(lba) (lba >> 24) | 0xE0
#define LBA_BITS_LOW(lba) (unsigned char)(lba & 0xFF)
#define LBA_BITS_MID(lba) (unsigned char)(lba >> 8)
#define LBA_BITS_HIGH(lba) (unsigned char)(lba >> 16)
#define LBA_PIO_READ_SECTORS 0x20


// Primary HDD
// Real hard drive (physical device, not a partition that looks like another drive.
#define HDD_TYPE_REAL_PRIMARY 0

/**
 * Disks type for creating disk devices.
 */
typedef struct Disk_s {
    unsigned int type;
    unsigned int sector_size;
} Disk;

/**
 * Read a block of data from a disk
 * @param hdd The disk to read from.
 * @param lba The starting logical block address
 * @param blocks The number of blocks to read.
 * @param buf A buffer to store the bytes of data.
 * @return 0 on disk read success, -1 on failure.
 */
int disk_read_block(const Disk *const hdd, unsigned int lba, unsigned int total, void *buf);

/**
 * Search and initialise hard drives.
 * NOTE: This is for future expansions, OS currently only works with a single primary disk
 */
void disks_init();

/**
 * Get the disk based on its index value
 * @param disk_index The number of the disk
 * @return pointer to disk device found at the index, or 0 (NULL) if disk not found.
 */
Disk *disk_get(unsigned int disk_index);

#endif // SIMPLEOS_DISK_H
